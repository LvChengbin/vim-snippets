# class
snippet ~cls "class C {}"
class ${1}{
	${0:${VISUAL}}
}
endsnippet

# class with constructor
snippet ~clsc "class C { constructor() {} }"
class ${1}{
	constructor( ${2:options = \{\}} ) {
		${0:${VISUAL}}
	}
}
endsnippet

# class extends from another object
snippet ~clse "class C extends S {}"
class ${1}extends ${2:Base} {
	${0:${VISUAL}}
}
endsnippet

# class extends from another object with a constructor
snippet ~clsec "class C extends E { constructor( o ) { super( o ) } }"
class ${1}extends ${2:Base} {
	constructor( ${3:options = \{\}} ) {
		super( ${4:options} );
		${0:${VISUAL}}
	}
}
endsnippet

# for
snippet ~for "for( let i = 0, l = x.length; i < l; i += 1 ) { const item = x[ i ]; }"
for( let ${1:i} = 0, l = ${2:list}.length; $1 < $2; $1 += 1 ) {
	const ${3:item} = $2[ $1 ];
	${0:${VISUAL}}
}
endsnippet

# for...of
snippet ~forof "for( let item of list ) {}"
for( let ${1:item} of ${2:list} ) {
	${0:${VISUAL}}
}
endsnippet

# for...in
snippet ~forin "for( let prop in obj ) { const item = obj[ prop ]; }"
for( let ${1:prop} in ${2:obj} ) {
	const ${3:item} = $2[ $1 ];
	${0:${VISUAL}}
}
endsnippet
# functions

# arrow function
snippet ~f "( arg1, arg2, ... ) => {}"
( ${1} ) => {
	${0:${VISUAL}}
}
endsnippet

snippet ~fun "function( arg1, arg2, ... ) {}"
function( ${1} ) {
	${0:${VISUAL}}
}
endsnippet

snippet ~nfun "function fn( arg1, arg2, ... ) {}"
function ${1}( ${2} ) {
	${0:${VISUAL}}
}
endsnippet

# async arrow function
snippet ~af "async ( arg1, arg2, ... ) => {}"
async ( ${1} ) => {
	${0:${VISUAL}}
}
endsnippet

# async method
snippet ~am "async func() {}"
async ${1}( ${2} ) {
	${0:${VISUAL}}
}
endsnippet

# async anonymous function
snippet ~afun "async function( arg1, arg2, ... ) {}"
async function( ${1} ) {
	${0:${VISUAL}}
}
endsnippet

# async named function
snippet ~anfun "async function fn( arg1, arg2, ... ) {}"
async function ${1}( ${2} ) {
	${0:${VISUAL}}
}
endsnippet

# arrow function with only one argument
snippet ~f? "x => {}"
${1} => {
	${0:${VISUAL}}
}
endsnippet

# async arrow function with only one argument
snippet ~af? "async x => {}"
async ${1} => {
	${0:${VISUAL}}
}
endsnippet

# an iife
snippet ~iife "( () => {} )()"
( () => {
	${0:${VISUAL}}
} )();
endsnippet

# throw

# throw an Error instance
snippet ~tr "throw new Error( error message )"
throw new Error( '${1:error message}' );
endsnippet

# throw an TypeError instance
snippet ~ttr "throw new TypeError( error message )"
throw new TypeError( '${1:error message}' );
endsnippet

# try
snippet ~try "try { ... } catch( e ) { ... }"
try {
	${0:${VISUAL}}
} catch( ${1:e} ) {
	${2:/* handle error*/}
}
endsnippet

# try catch statement with finally
snippet ~tryf "try { ... } catch( e ) { ... } finally { ... }"
try {
	${3:${VISUAL}}
} catch( ${1:e} ) {
	${2:/* handle error*/}
} finally {
	${0:${VISUAL}}
}
endsnippet

# switch
snippet ~switch
switch( ${1} ) {
	case '${2}' :
		${3}
		break;
	${0}
	default :
		${4}
}
endsnippet

snippet ~case
case '${1}' :
	${0:${VISUAL}}
	${2:break;}
endsnippet

#symbol
snippet ~symbol "const A_B_C = Symbol( 'a_b_c' )"
const ${1} = Symbol( '${1/\w/\l$0/g}' )
endsnippet

# if

# if( ... ) break
snippet ~ifb "if( conditions ) break;"
if( ${0:/* conditions */} ) break;
endsnippet

# if( ... ) continue
snippet ~ifc "if( conditions ) continue;"
if( ${0:/* conditions */} ) continue;
endsnippet

# if ( ...) return
snippet ~ifr "if( conditions ) return;"
if( ${1:/* conditions */} ) return ${0:${VISUAL}};
endsnippet

# assignment

snippet ~|| "x || ();"
${1} || ( $1 = ${2} );
endsnippet

# json

# JSON.parse
snippet ~jp "JSON.parse( object )"
JSON.parse( ${0} );
endsnippet

# JSON.stringify
snippet ~jstr "JSON.stringify( json )"
JSON.stringify( ${0} );
endsnippet

# dom selector

# document.querySelector( selector )
snippet ~$ "document.querySelector( selectors )"
${0:document}.querySelector( '${1:selector}' );
endsnippet

# document.querySelectorAll( selector )
snippet ~$$ "document.querySelectorAll( selectors )"
${0:document}.querySelectorAll( '${1:selector}' );
endsnippet

# document.getElementById( id )
snippet ~$#
document.getElementById( '${0:id}' );
endsnippet

# console
snippet ~cl "console.log( ...args )"
console.log( ${0} );
endsnippet

snippet ~cw "console.warn( ...args )"
console.warn( ${0} );
endsnippet

snippet ~cd "console.debug( ...args )"
console.debug( ${0} );
endsnippet

snippet ~ce "console.error( ...args )"
console.log( ${0} );
endsnippet

snippet ~ci "console.info( ...args )"
console.log( ${0} );
endsnippet

# use strict
snippet ~us "'use strict'"
'use strict';
endsnippet

# modules

# import es6 module
snippet ~im "import X from 'path';"
import ${1} from '${0}';
endsnippet

snippet ~imx "import {a,b} from 'path';"
import { ${1} } from '${0}';
endsnippet

# import packages from @lvchengbin
snippet ~imm "import x from '@lvchengbin/x';"
import ${1} from '@lvchengbin/${1/\w/\l$0/g}';
endsnippet

# import packages from current dir
snippet ~imrel "import x from './x';"
import ${1} from './${1/\w/\l$0/g}';
endsnippet

# import file from @lvchengbin/is
snippet ~immis "import isXX from '@lvchengbin/is/src/xx';"
import is${1} from '@lvchengbin/is/src/${1/\w/\l$0/g}';
endsnippet

snippet ~exd "export default x;"
export default ${0};
endsnippet

snippet ~mexi "module.exports.x = {};"
module.exports.${1} = ${0:${VISUAL}}
endsnippet

snippet ~mex "module.exports.x = {};"
module.exports = ${0:${VISUAL}}
endsnippet

#require
snippet ~r "const x = require( 'path' );"
const ${1} = require( '${2}' );
endsnippet

snippet ~rrel "const x = require( './x' );"
const ${1} = require( './${1/\w/\l$0/g}${0:${VISUAL}}' );
endsnippet

snippet ~rm "const x = require( '@lvchengbin/x' );"
const ${1} = require( '@lvchengbin/${1/\w/\l$0/g}' );
endsnippet

# Promise

snippet ~then".then( () => {} );"
.then( ${1} => { ${0:${VISUAL}} } );

# .then().catch()
snippet ~thenc".then( () => {} ).catch( e => console.log( e ) );"
.then( ${1} => {
	${0:${VISUAL}}
} ).catch( e => {
	console.log( e );
} );
endsnippet

# settimeout
snippet ~sto "setTimeout(() => {}, delay);"
setTimeout( () => {
	${0:${VISUAL}}
}, ${1:0})
endsnippet

# call
snippet ~call "func.call( this, ...args )"
${1}.call( ${2:this}, ${3:...args} );
endsnippet

# multiple lines comment
snippet ~cmt "/** */"
/**
 * ${0:${VISUAL}}
 */
endsnippet
